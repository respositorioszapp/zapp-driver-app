{"ast":null,"code":"import { __awaiter, __decorate } from \"tslib\";\nimport { Component, ViewChild } from '@angular/core';\nimport { Plugins, Capacitor, App, Network } from '@capacitor/core';\nconst {\n  Geolocation,\n  Haptics,\n  Modals,\n  LocalNotifications\n} = Plugins;\nimport { IonRefresher } from '@ionic/angular';\nimport { ViewDetailPage } from 'src/app/screens/forms/view-detail/view-detail.page';\nimport { Subject } from 'rxjs';\nimport { environment } from '../../../../environments/environment.prod';\nimport { take } from 'rxjs/operators';\nimport BackgroundGeolocation from \"cordova-background-geolocation-lt\";\nimport { RequestLocationPermissionPage } from '../../forms/request-location-permission/request-location-permission.page';\nlet HomePage = class HomePage {\n  constructor(auth, request, ui, router, loadingController, realtime, network, db, place, days, backgroundService) {\n    this.auth = auth;\n    this.request = request;\n    this.ui = ui;\n    this.router = router;\n    this.loadingController = loadingController;\n    this.realtime = realtime;\n    this.network = network;\n    this.db = db;\n    this.place = place;\n    this.days = days;\n    this.backgroundService = backgroundService;\n    this.count = 1;\n    this.spinner = false;\n    this.orders = [];\n    this.image = \"assets/imgs/avatar.svg\";\n    this.latLng = new Subject();\n    this.orderNearYou = [];\n    this.allLoaded = false;\n    this.dataParams = {\n      total: 0,\n      per_page: 5,\n      page: 1,\n      filters: []\n    };\n    this.nextPage = \"\";\n    this.to = 0;\n    this.loadedText = \"\";\n    this.loading = false;\n    this.fcmId = null;\n    this.interval = null;\n  }\n\n  ngAfterContentInit() {\n    this.startPosition();\n  }\n\n  ngOnInit() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.user = this.auth.user;\n      yield LocalNotifications.requestPermission(); //\n\n      App.addListener(\"appStateChange\", state => {\n        clearInterval(this.interval);\n        console.log(\"Background mode\");\n\n        if (!state.isActive) {\n          //Cuando la app está en segundo plano, esperar 6 minutos y reiniciar escuchar la posición\n          if (this.auth.user != null && this.auth.user.available != 0) {// setTimeout(() => {\n            //   this.initializeBackgroundGeolocation();\n            //   this.startWatchingPosition()\n            // }, 240000)\n          }\n        } else {}\n      });\n      this.startPosition();\n    });\n  }\n\n  ionViewDidEnter() {\n    return __awaiter(this, void 0, void 0, function* () {\n      // this.\n      // this.startWatchingPosition();\n      // this.initializeBackgroundGeolocation()\n      Network.addListener('networkStatusChange', status => __awaiter(this, void 0, void 0, function* () {\n        console.log(\"Network status changed\", status);\n        localStorage.setItem(\"network_status\", JSON.stringify(status));\n\n        if (status.connected) {\n          Geolocation.clearWatch({\n            id: this.watchPositionId\n          });\n\n          if (Capacitor.platform !== 'web') {// await this.backgroundGeolocation.removeAllListeners()\n          } // this.initializeBackgroundGeolocation()\n\n        }\n      }));\n    });\n  }\n\n  ionViewWillEnter() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.user = this.auth.user;\n      const i = 0;\n\n      if (this.auth.person.ordersNearYou) {\n        this.orderNearYou = this.auth.person.ordersNearYou;\n      }\n\n      this.closeSubscriptions();\n      this.initSubscriptions();\n      this.verifyCurrentOrder();\n\n      if (this.user.available != 0) {\n        this.loadData();\n      } else {\n        if (this.network.getNetworkStatus().connected) {\n          let loader;\n\n          if (!localStorage.getItem(\"current_order\")) {\n            loader = yield this.loadingController.create({\n              message: \"Por favor espere...\"\n            });\n            yield loader.present();\n          }\n\n          this.request.get(`driver/documents/${this.auth.user.id}`).subscribe(res => __awaiter(this, void 0, void 0, function* () {\n            if (!localStorage.getItem(\"current_order\")) {\n              (yield loader).dismiss();\n            }\n\n            const documents = res.data.documents;\n            const photo = documents.filter(d => d[\"document_type \"] == \"Foto del conductor\");\n\n            if (photo.length > 0) {\n              this.image = photo[photo.length - 1].url;\n            }\n          }), err => __awaiter(this, void 0, void 0, function* () {\n            if (!localStorage.getItem(\"current_order\")) {\n              (yield loader).dismiss();\n            }\n          }));\n        } else {\n          this.ui.showToast(\"Verifique su conexión\");\n        }\n      }\n\n      const position = yield Geolocation.getCurrentPosition({\n        enableHighAccuracy: true\n      }); // (await loader).dismiss();\n\n      localStorage.setItem(\"latitude\", position.coords.latitude.toString());\n      localStorage.setItem(\"longitude\", position.coords.longitude.toString());\n    });\n  }\n\n  verifyCurrentOrder() {\n    if (localStorage.getItem(\"current_order\")) {\n      const order = JSON.parse(localStorage.getItem(\"current_order\"));\n\n      if (order.service_type_id == 3) {\n        this.request.get(`order/show_order/${order.id}`).subscribe(res => __awaiter(this, void 0, void 0, function* () {\n          const orderDatabase = res.data;\n          const myDetails = orderDatabase.detail.filter(d => d.people_id == this.auth.user.id);\n\n          if (myDetails.length > 0) {\n            const detailData = myDetails[0];\n\n            if (detailData.status == 25) {\n              if (orderDatabase.status_order == 25) {\n                localStorage.removeItem(\"current_order\");\n                yield this.ui.presentAlert({\n                  mode: 'ios',\n                  header: \"Advertencia\",\n                  message: \"Esta orden ya ha sido finalizada\"\n                });\n              } else {\n                const otherDetails = orderDatabase.detail.filter(d => d.people_id != this.auth.user.id);\n\n                if (otherDetails.length == 0) {\n                  this.endService(orderDatabase);\n                }\n              }\n            } else {\n              this.viewDetail(order);\n            }\n          }\n        }));\n      } else {\n        this.viewDetail(order);\n      }\n    }\n  }\n\n  clearLocals() {\n    localStorage.removeItem(\"current_order\");\n    localStorage.removeItem(\"total_charge\");\n    localStorage.removeItem(\"initTimer\");\n    localStorage.removeItem(\"client_configuration_data\");\n    localStorage.removeItem(\"configuration_data\");\n    localStorage.removeItem(\"timer\");\n    localStorage.removeItem(\"bearing\");\n    localStorage.removeItem(\"bearing_used\");\n    localStorage.removeItem(\"app_close_date\");\n    const idInterval = Number(localStorage.getItem(\"id_interval\"));\n    clearInterval(idInterval);\n    localStorage.removeItem(\"id_interval\");\n  }\n\n  getOrderAlertMessage(order, isMassive) {\n    const pay = order.payment_method.toLowerCase() == 'efectivo' ? order.zapp_store_order == 1 ? order.total_zapp_store : order.total : 0;\n    let details = order.details ? order.details : order.detail;\n    let message = \"Tipo de servicio: <strong>\" + order.service_type + \"</strong>\";\n\n    if (order.service_type_id != \"3\") {\n      message += \"<br/> Recorrido :  <strong>\" + (order.round_trip == 1 ? 'Ida y Vuelta' : 'Ida') + \"</strong>\";\n      message += \"<br>Cantidad :<strong>\" + details.length + \" direcciones </strong>\";\n      message += \"<br> Método de pago: <strong>\" + order.payment_method + \"</strong>\";\n      +\"<br> Tipo de accesorio: <strong>\" + order.accessory_type + \"</strong>\";\n      message += \"<br> Día del servicio : <strong>\" + order.date + \"</strong>\";\n    }\n\n    if (order.service_type_id == \"1\") {\n      message += \"<br> Dirección A : <strong>\" + details[0].address + \"</strong>\" + \"<br> Dirección B :<strong>\" + details[1].address + \"</strong>\";\n    }\n\n    if (order.service_type_id == \"3\") {\n      message += \"<br> Día del servicio : <strong>\" + order.date + \"</strong>\";\n      message += \"<br> Dirección : <strong>\" + details[0].address + \"</strong>\";\n      message += \"<br> Hora de inicio : <strong>\" + details[0].start_time + \"</strong>\" + \"<br> Hora de salida :<strong>\" + details[0].departure_time + \"</strong>\";\n      message += \"<br> Número de horas :<strong>\" + details[0].number_of_hours + \"</strong>\";\n    } else {\n      if (order.payment_method.toLowerCase() == 'masivo') {\n        let cash = 0;\n        details.forEach(d => {\n          cash += d.declared_value ? d.declared_value : 0;\n        });\n        message += \"<br> Cobrar: <strong>$\" + cash + \"</strong>\";\n      } else {\n        message += \"<br> Cobrar: <strong>$\" + pay + \"</strong>\";\n      }\n    }\n\n    return message;\n  }\n\n  initSubscriptions() {\n    console.log(\"Init Subscription\");\n    this.startMassiveOrderSubscription();\n    this.startNewOrdersSubsriptions();\n    this.startStatusSubscription();\n    this.listenToVersionChange();\n  }\n\n  listenToVersionChange() {\n    this.versionSubscription = this.realtime.getFirebaseCollectionObject(\"code_version_mobile/5\").valueChanges().subscribe(res => __awaiter(this, void 0, void 0, function* () {\n      if (res != null) {\n        console.log(\"Res version code\", res);\n\n        if (localStorage.getItem(\"current_version\")) {\n          const status = JSON.parse(localStorage.getItem(\"current_version\"));\n          console.log(\"current_version\", status);\n          console.log(\"res\", res);\n          console.log(\"equal\", res === status);\n\n          if (res.code == status.code) {\n            return;\n          } else {\n            localStorage.setItem(\"current_version\", JSON.stringify(res));\n          }\n        } else {\n          console.log(\"elseeee\");\n          localStorage.setItem(\"current_version\", JSON.stringify(res));\n        }\n\n        if (res.code != environment.VERSION_NAME) {\n          yield this.ui.presentAlert({\n            mode: 'ios',\n            header: '¡Hay nueva versión disponible!',\n            message: 'Por favor, descargala',\n            buttons: [{\n              text: 'Aceptar',\n              role: 'cancel',\n              cssClass: 'secondary',\n              handler: blah => {\n                console.log(\"Execute\");\n                this.auth.logOut();\n              }\n            }]\n          });\n        }\n      } else {\n        this.realtime.getFirebaseCollectionObject(\"code_version_mobile/5\").set({\n          code: environment.VERSION_NAME\n        });\n      }\n    }));\n  }\n\n  startStatusSubscription() {\n    let verified = this.auth.user.verified;\n    this.statusSubscription = this.realtime.getStatus().valueChanges().subscribe(res => __awaiter(this, void 0, void 0, function* () {\n      console.log(\"Status\", res);\n\n      if (res != null) {\n        if (localStorage.getItem(\"current_status\")) {\n          const status = JSON.parse(localStorage.getItem(\"current_status\"));\n          console.log(\"current_status\", status);\n          console.log(\"res\", res);\n          console.log(\"equal\", res === status);\n\n          if (res.verified == status.verified && res.documents == status.documents && res.first_time_verified == status.first_time_verified) {\n            return;\n          } else {\n            localStorage.setItem(\"current_status\", JSON.stringify(res));\n          }\n        } else {\n          console.log(\"elseeee\");\n          localStorage.setItem(\"current_status\", JSON.stringify(res));\n        }\n\n        if (verified == 1) {\n          verified = 0;\n          return;\n        }\n\n        this.auth.user.verified = res.verified;\n        this.user.verified = res.verified;\n        let header;\n\n        if (res.verified == 1 && res.documents == 1 || res.verified == 1) {\n          header = '¡Enhorabuena, has sido verificado!';\n\n          if (this.user.available == 1) {\n            this.loadData();\n          }\n        } else {\n          if (res.verified == 0 && res.documents == 1) {\n            header = res.first_time_verified == 0 ? 'Enhorabuena, has completado tu registro, una operadora está verficando tu información y posteriormente serás activado ' : '¡Tu usuario ha sido inhabilitado, contacta al administrador!';\n            console.log(\"Header\", header);\n            this.user.available = 0;\n            this.auth.user.available = 0;\n            this.orders = [];\n          } else {\n            if (res.verified == 0 && res.documents == 0) {\n              header = 'Completa tu información para terminar el regitro y serás habilitado por una operadora';\n            }\n          }\n        }\n\n        this.auth.setUser(this.user);\n        let message;\n        this.ui.presentAlert({\n          mode: 'ios',\n          header,\n          message,\n          buttons: [{\n            text: 'Aceptar',\n            role: res.verified == 0 && res.documents == 0 ? undefined : 'cancel',\n            cssClass: 'secondary',\n            handler: () => {\n              if (res.verified == 0 && res.documents == 0) {\n                this.router.navigate(['tabs/documents']);\n              }\n\n              console.log('cerrar');\n            }\n          }]\n        });\n\n        if (!localStorage.getItem(\"firstTime\" + this.auth.user.id)) {\n          localStorage.setItem(\"firstTime\" + this.auth.user.id, JSON.stringify({}));\n          let message = \"Zapp Driver App te da la bienvenida <br> \";\n          message += this.auth.person.first_name.toString().toUpperCase() + \" \";\n          message += this.auth.person.last_name.toString().toUpperCase() + \" <br> \";\n          message += \"Te recomendamos que para tener la mejor experiencia posible que mantengas el GPS encendido <br>\";\n          message += \" <br> Muchas gracias y disfruta de la aplicación\";\n          this.ui.presentAlert({\n            mode: 'ios',\n            header: \"Bienvennido\",\n            message,\n            buttons: [{\n              text: 'Aceptar',\n              cssClass: 'secondary',\n              handler: res => __awaiter(this, void 0, void 0, function* () {})\n            }]\n          });\n        }\n      } else {\n        this.realtime.getStatus().update({\n          verified: 0,\n          documents: 0,\n          first_time_verified: 0\n        });\n      }\n    }));\n  }\n\n  startMassiveOrderSubscription() {\n    this.massiveOrdersSubscription = this.realtime.getMassivesOrders().valueChanges().subscribe(res => __awaiter(this, void 0, void 0, function* () {\n      console.log(\"Massive order\", res);\n\n      if (res != null) {\n        if (res.new_order == 1) {\n          const order = res.orders;\n\n          if (order != null && Object.keys(order).length > 0) {\n            const {\n              message: activeMessage,\n              active\n            } = yield this.isOrderActive(order);\n\n            if (active) {\n              if (!localStorage.getItem(\"current_order\")) {\n                this.playAudio();\n\n                if (!this.orderNearYou.find(o => o.id == order.id)) {\n                  this.orderNearYou.push(order);\n                  this.auth.person.ordersNearYou = this.orderNearYou;\n                  this.auth.setPerson(this.auth.person);\n                }\n              }\n            }\n          }\n        }\n      }\n    }));\n  }\n\n  startNewOrdersSubsriptions() {\n    this.orderSubscription = this.realtime.getNewOrder().valueChanges().subscribe(res => {\n      console.log(\"res\", res);\n\n      if (res != null) {\n        console.log(\"snapshot\", res);\n\n        if (res.new_order == 1) {\n          const order = res.orders;\n          const item = this.orders.find(o => o.id == order.id);\n\n          if (!item) {\n            this.playAudio(); // Haptics.vibrate();\n\n            this.orders.unshift(order);\n            this.realtime.getNewOrder().update({\n              new_order: 0,\n              orders: {},\n              proximity: 1\n            });\n            const details = order.details ? order.details : order.detail;\n            this.realtime.getFirebaseCollectionObject(`order_detail_report/${order.id}/${details[0].id}`).valueChanges().subscribe(res => {\n              if (res == null) {\n                this.realtime.getFirebaseCollectionObject(`order_detail_report/${order.id}/${details[0].id}`).set(Object.assign({}, details[0]));\n              }\n            });\n          }\n        }\n      }\n    });\n  }\n\n  closeSubscriptions() {\n    if (this.statusSubscription) {\n      this.statusSubscription.unsubscribe();\n    }\n\n    if (this.orderSubscription) {\n      this.orderSubscription.unsubscribe();\n    }\n\n    if (this.massiveOrdersSubscription) {\n      this.massiveOrdersSubscription.unsubscribe();\n    }\n  }\n\n  ionViewWillLeave() {\n    this.closeSubscriptions();\n  }\n\n  isAboutToEnd(item) {\n    return item.details.every(d => d.status == 25 || d.status == 48);\n  }\n\n  endService(item) {\n    console.log(\"Order\", item);\n    const data = new FormData(); // this.ui.showToast(\"Latitude \" + this.latitude + \" Longitud\" + this.longitude)\n\n    const latitude = localStorage.getItem(\"latitude\");\n    const longitude = localStorage.getItem(\"longitude\");\n    data.append(\"order_id\", item.id);\n    data.append(\"latitude\", latitude);\n    data.append(\"longitude\", longitude);\n    data.append(\"description\", \"Finalización Servicio\");\n    data.append(\"user_id\", this.auth.user.id.toString());\n    const loader = this.ui.loading(\"Por favor espere...\");\n    this.request.post(\"driver/end_service\", data).subscribe(res => __awaiter(this, void 0, void 0, function* () {\n      (yield loader).dismiss();\n      item.status_order = 25;\n      this.ui.showToast(\"Orden \" + item.id + \" finalizada.\", () => {});\n    }), err => __awaiter(this, void 0, void 0, function* () {\n      console.log(\"Error\", err);\n      (yield loader).dismiss();\n\n      if (err.status == 400) {\n        this.ui.showToast(err.error.messages[0]);\n      }\n    }));\n  }\n\n  startPosition() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.auth.user && this.auth.user.available) {\n        if (Capacitor.platform !== 'web') {\n          yield BackgroundGeolocation.stop();\n          this.initializeBackgroundGeolocation();\n        } else {\n          yield Geolocation.clearWatch({\n            id: this.watchPositionId\n          });\n          this.startWatchingPosition();\n        }\n      }\n    });\n  }\n\n  stopPosition() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield Geolocation.clearWatch({\n        id: this.watchPositionId\n      });\n\n      if (Capacitor.platform !== 'web') {\n        // await this.backgroundGeolocation.removeAllListeners()\n        yield BackgroundGeolocation.stop();\n      }\n    });\n  }\n\n  startWatchingPosition(mode) {\n    if (this.auth.user.available != 0) {\n      this.watchPositionId = Geolocation.watchPosition({// enableHighAccuracy: true\n      }, (position, err) => __awaiter(this, void 0, void 0, function* () {\n        if (!err) {\n          console.log(`Location Update`, JSON.stringify(position)); // if (Capacitor.platform != 'web') {\n          //   Haptics.vibrate();\n          // }\n\n          const latitude = localStorage.getItem(\"latitude\");\n          const longitude = localStorage.getItem(\"longitude\");\n\n          if (latitude && longitude) {\n            try {\n              console.log(`Location Update Success`);\n              localStorage.setItem(\"latitude\", position.coords.latitude.toString());\n              localStorage.setItem(\"longitude\", position.coords.longitude.toString());\n              const heading = position.coords.heading ? position.coords.heading : 0;\n              let bearing_used;\n\n              if (localStorage.getItem(\"bearing\")) {\n                const bearing = localStorage.getItem(\"bearing\");\n                bearing_used = bearing;\n              }\n\n              localStorage.setItem(\"bearing\", heading.toString());\n              let bearing = 0;\n\n              if (bearing_used) {\n                bearing = bearing_used;\n              } else {\n                bearing = 180;\n              }\n\n              const actual_angle = heading - bearing;\n              this.latLng.next({\n                lat: position.coords.latitude,\n                lng: position.coords.longitude,\n                bearing: actual_angle\n              });\n              yield this.realtime.getUserGeolocation().update({\n                key: this.auth.user.id,\n                user_id: this.auth.user.id,\n                latitude: position.coords.latitude.toString(),\n                longitude: position.coords.longitude.toString(),\n                city_id: this.auth.person.city_id,\n                state_id: Number(this.auth.person.state_id),\n                level_id: Number(this.auth.user.level_id),\n                // last_active: Date.now(),\n                available: this.auth.user.available,\n                driver_name: this.auth.user.name,\n                transport_type_id: this.auth.vehicles.transport_type_id\n              });\n\n              if (localStorage.getItem(\"current_order\")) {\n                const order = JSON.parse(localStorage.getItem(\"current_order\"));\n                console.log(\"Order Next 2\");\n\n                if (order) {\n                  let path = 'order_gps/' + order.id + '/' + this.auth.user.id;\n                  this.db.object(path).update({\n                    order: order.id,\n                    key: this.auth.user.id,\n                    vehicleId: this.auth.vehicles.id,\n                    lat: position.coords.latitude,\n                    lng: position.coords.longitude,\n                    oldLat: position.coords.latitude,\n                    oldLng: position.coords.longitude,\n                    angle: actual_angle,\n                    // last_active: Date.now(),\n                    code: environment.VERSION_NAME\n                  });\n                  this.realtime.getFirebaseCollectionObject('order_history_reports/' + order.id + '/' + this.auth.user.id).valueChanges().pipe(take(1)).subscribe(value => {\n                    // this.ui.showToast(\"Locations \" + \"Latitude \" + lat + \" Longitud \" + lng + \"Hora\" + Date.now())\n                    if (value === null) {\n                      const locations = [{\n                        lat: position.coords.latitude,\n                        lng: position.coords.longitude,\n                        created_at: Date.now()\n                      }]; // this.ui.showToast(\"Locations \" + \"Latitude \" + lat + \" Longitud \" + lng + \"Hora\" + Date.now())\n\n                      this.realtime.getFirebaseCollectionObject('order_history_reports/' + order.id + '/' + this.auth.user.id).set({\n                        order,\n                        key: this.auth.user.id,\n                        user_id: this.auth.user.id,\n                        locations,\n                        code: environment.VERSION_NAME\n                      });\n                    } else {\n                      // update\n                      let locations = value.locations;\n                      locations.push({\n                        lat: position.coords.latitude,\n                        lng: position.coords.longitude,\n                        created_at: Date.now()\n                      });\n                      this.realtime.getFirebaseCollectionObject('order_history_reports/' + order.id + '/' + this.auth.user.id).update({\n                        order,\n                        key: this.auth.user.id,\n                        locations,\n                        code: environment.VERSION_NAME\n                      });\n                    }\n                  });\n                }\n              }\n            } catch (e) {\n              console.log(`Location Update Error`, e);\n            }\n          } else {\n            localStorage.setItem(\"latitude\", position.coords.latitude.toString());\n            localStorage.setItem(\"longitude\", position.coords.longitude.toString());\n            const heading = position.coords.heading ? position.coords.heading : 0;\n            let bearing_used;\n\n            if (localStorage.getItem(\"bearing\")) {\n              const bearing = localStorage.getItem(\"bearing\");\n              bearing_used = bearing;\n            }\n\n            localStorage.setItem(\"bearing\", heading.toString());\n            let bearing = 0;\n\n            if (bearing_used) {\n              bearing = bearing_used;\n            } else {\n              bearing = 180;\n            }\n\n            const actual_angle = heading - bearing;\n            this.realtime.getUserGeolocation().update({\n              key: this.auth.user.id,\n              user_id: this.auth.user.id,\n              latitude: position.coords.latitude.toString(),\n              longitude: position.coords.longitude.toString(),\n              city_id: this.auth.person.city_id,\n              state_id: Number(this.auth.person.state_id),\n              level_id: Number(this.auth.user.level_id),\n              // last_active: Date.now(),\n              available: this.auth.user.available,\n              driver_name: this.auth.user.name,\n              transport_type_id: this.auth.vehicles.transport_type_id\n            });\n\n            if (localStorage.getItem(\"current_order\")) {\n              const order = JSON.parse(localStorage.getItem(\"current_order\"));\n              console.log(\"Order Next 2\");\n\n              if (order) {\n                let path = 'order_gps/' + order.id + '/' + this.auth.user.id;\n                this.db.object(path).update({\n                  order: order.id,\n                  key: this.auth.user.id,\n                  vehicleId: this.auth.vehicles.id,\n                  lat: position.coords.latitude,\n                  lng: position.coords.longitude,\n                  oldLat: position.coords.latitude,\n                  oldLng: position.coords.longitude,\n                  angle: actual_angle,\n                  // last_active: Date.now(),\n                  code: environment.VERSION_NAME\n                });\n                this.realtime.getFirebaseCollectionObject('order_history_reports/' + order.id + '/' + this.auth.user.id).valueChanges().pipe(take(1)).subscribe(value => {\n                  // this.ui.showToast(\"Locations \" + \"Latitude \" + lat + \" Longitud \" + lng + \"Hora\" + Date.now())\n                  if (value === null) {\n                    const locations = [{\n                      lat: position.coords.latitude,\n                      lng: position.coords.longitude,\n                      created_at: Date.now()\n                    }]; // this.ui.showToast(\"Locations \" + \"Latitude \" + lat + \" Longitud \" + lng + \"Hora\" + Date.now())\n\n                    this.realtime.getFirebaseCollectionObject('order_history_reports/' + order.id + '/' + this.auth.user.id).set({\n                      order,\n                      key: this.auth.user.id,\n                      user_id: this.auth.user.id,\n                      locations,\n                      code: environment.VERSION_NAME\n                    });\n                  } else {\n                    // update\n                    let locations = value.locations;\n                    locations.push({\n                      lat: position.coords.latitude,\n                      lng: position.coords.longitude,\n                      created_at: Date.now()\n                    });\n                    this.realtime.getFirebaseCollectionObject('order_history_reports/' + order.id + '/' + this.auth.user.id).update({\n                      order,\n                      key: this.auth.user.id,\n                      locations,\n                      code: environment.VERSION_NAME\n                    });\n                  }\n                });\n              }\n            }\n          }\n        } else {\n          yield Geolocation.clearWatch({\n            id: this.watchPositionId\n          });\n          this.startWatchingPosition();\n\n          if (Capacitor.platform !== 'web') {// await this.backgroundGeolocation.removeAllListeners()\n          }\n\n          this.initializeBackgroundGeolocation();\n        }\n      }));\n    } // setTimeout(async () => {\n    //   await Geolocation.clearWatch({ id: this.watchPositionId });\n    //   if (Capacitor.platform !== 'web') {\n    //     // await this.backgroundGeolocation.removeAllListeners()\n    //   }\n    //   this.startWatchingPosition();\n    //   this.initializeBackgroundGeolocation()\n    // }, 240000)\n\n  }\n\n  initializeBackgroundGeolocation() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.auth.user.available != 0) {\n        if (Capacitor.platform !== 'web') {\n          // 1.  Listen to events.\n          BackgroundGeolocation.onLocation(location => __awaiter(this, void 0, void 0, function* () {\n            console.log('[location] - ', location);\n\n            try {\n              localStorage.setItem(\"latitude\", location.coords.latitude.toString());\n              localStorage.setItem(\"longitude\", location.coords.longitude.toString());\n              const heading = location.coords.heading ? location.coords.heading : 0;\n              let bearing_used = 0;\n\n              if (localStorage.getItem(\"bearing\")) {\n                const bearing = localStorage.getItem(\"bearing\");\n                bearing_used = parseFloat(bearing);\n              }\n\n              localStorage.setItem(\"bearing\", heading.toString());\n              let bearing = 0;\n\n              if (bearing_used != 0) {\n                // Angle used before\n                bearing = bearing_used;\n              } else {\n                //Image original angle\n                bearing = 180;\n              }\n\n              const actual_angle = heading - bearing; //Notified modal to update the driver position\n\n              this.latLng.next({\n                lat: location.coords.latitude,\n                lng: location.coords.longitude,\n                bearing: actual_angle\n              }); //Update firebase document driver_geolocation/${city}/${driver_id}\n\n              yield this.realtime.getUserGeolocation().update({\n                key: this.auth.user.id,\n                user_id: this.auth.user.id,\n                latitude: location.coords.latitude.toString(),\n                longitude: location.coords.longitude.toString(),\n                city_id: this.auth.person.city_id,\n                state_id: Number(this.auth.person.state_id),\n                level_id: Number(this.auth.user.level_id),\n                // last_active: Date.now(),\n                available: this.auth.user.available,\n                driver_name: this.auth.user.name,\n                transport_type_id: this.auth.vehicles.transport_type_id\n              });\n              console.log(\"Location Update User Location\");\n\n              if (localStorage.getItem(\"current_order\")) {\n                const order = JSON.parse(localStorage.getItem(\"current_order\")); //Set firebase collection path for order gps order_gps/${order_id}/${user_id}\n\n                let path = 'order_gps/' + order.id + '/' + this.auth.user.id; //Update Driver posititon in the order\n\n                yield this.db.object(path).update({\n                  order: order.id,\n                  key: this.auth.user.id,\n                  vehicleId: this.auth.vehicles.id,\n                  lat: location.coords.latitude,\n                  lng: location.coords.longitude,\n                  oldLat: location.coords.latitude,\n                  oldLng: location.coords.longitude,\n                  angle: actual_angle,\n                  code: environment.VERSION_NAME\n                });\n                console.log(\"Location Update User Location in Order\");\n              } else {}\n            } catch (e) {\n              console.log(`Location Update Error`, e); // this.ui.showToast(\"Error\" + JSON.stringify(e))\n            }\n          }));\n          BackgroundGeolocation.onMotionChange(event => __awaiter(this, void 0, void 0, function* () {\n            console.log('[motionchange] - ', event.isMoving, event.location);\n            const {\n              location\n            } = event;\n\n            try {\n              localStorage.setItem(\"latitude\", event.location.coords.latitude.toString());\n              localStorage.setItem(\"longitude\", event.location.coords.longitude.toString());\n              const heading = event.location.coords.heading ? event.location.coords.heading : 0;\n              let bearing_used = 0;\n\n              if (localStorage.getItem(\"bearing\")) {\n                const bearing = localStorage.getItem(\"bearing\");\n                bearing_used = parseFloat(bearing);\n              }\n\n              localStorage.setItem(\"bearing\", heading.toString());\n              let bearing = 0;\n\n              if (bearing != 0) {\n                // Angle used before\n                bearing = bearing_used;\n              } else {\n                //Image original angle\n                bearing = 180;\n              }\n\n              const actual_angle = heading - bearing; //Notified modal to update the driver position\n\n              this.latLng.next({\n                lat: event.location.coords.latitude,\n                lng: event.location.coords.longitude,\n                bearing: actual_angle\n              }); //Update firebase document driver_geolocation/${city}/${driver_id}\n\n              yield this.realtime.getUserGeolocation().update({\n                key: this.auth.user.id,\n                user_id: this.auth.user.id,\n                latitude: event.location.coords.latitude.toString(),\n                longitude: event.location.coords.longitude.toString(),\n                city_id: this.auth.person.city_id,\n                state_id: Number(this.auth.person.state_id),\n                level_id: Number(this.auth.user.level_id),\n                // last_active: Date.now(),\n                available: this.auth.user.available,\n                driver_name: this.auth.user.name,\n                transport_type_id: this.auth.vehicles.transport_type_id\n              });\n              console.log(\"Location Update User Location\");\n\n              if (localStorage.getItem(\"current_order\")) {\n                const order = JSON.parse(localStorage.getItem(\"current_order\"));\n\n                if (order) {\n                  let path = 'order_gps/' + order.id + '/' + this.auth.user.id;\n                  yield this.db.object(path).update({\n                    order: order.id,\n                    key: this.auth.user.id,\n                    vehicleId: this.auth.vehicles.id,\n                    lat: event.location.coords.latitude,\n                    lng: event.location.coords.longitude,\n                    oldLat: event.location.coords.latitude,\n                    oldLng: event.location.coords.longitude,\n                    angle: actual_angle,\n                    // last_active: Date.now(),\n                    code: environment.VERSION_NAME\n                  });\n                  console.log(\"Location Update User Location in Order\");\n                }\n              } else {}\n            } catch (e) {\n              console.log(`Location Update Error`, e);\n              this.ui.showToast(\"Error\" + JSON.stringify(e));\n            }\n          }));\n          BackgroundGeolocation.onHttp(response => {\n            console.log('[http] - ', response.success, response.status, response.responseText);\n          });\n          BackgroundGeolocation.onProviderChange(event => {\n            console.log('[providerchange] - ', event.enabled, event.status, event.gps);\n          }); // 2.  Configure the plugin with #ready\n\n          BackgroundGeolocation.ready({\n            stopTimeout: 1,\n            debug: !environment.production,\n            logLevel: BackgroundGeolocation.LOG_LEVEL_VERBOSE,\n            desiredAccuracy: BackgroundGeolocation.DESIRED_ACCURACY_HIGH,\n            distanceFilter: 10,\n            stopOnTerminate: false,\n            startOnBoot: true,\n            locationAuthorizationRequest: 'Always',\n            backgroundPermissionRationale: {\n              title: \"Allow access to this device's location in the background?\",\n              message: \"In order to allow X, Y and Z in the background, please enable 'Allow all the time' permission\",\n              positiveAction: \"Change to Allow all the time\",\n              negativeAction: \"Cancel\"\n            },\n            activityType: BackgroundGeolocation.ACTIVITY_TYPE_AUTOMOTIVE_NAVIGATION,\n            foregroundService: true,\n            triggerActivities: \"on_foot, walking, running,in_vehicle,on_bicycle\"\n          }, state => __awaiter(this, void 0, void 0, function* () {\n            console.log('[ready] BackgroundGeolocation is ready to use');\n\n            if (!state.enabled) {\n              yield BackgroundGeolocation.start();\n              BackgroundGeolocation.changePace(true); // 3.  Start tracking.\n\n              if (!localStorage.getItem(\"background_location_accepted\")) {\n                // Is Android device ignoring battery optimizations?\n                this.ui.presentModal(RequestLocationPermissionPage);\n              }\n            }\n          }));\n        }\n      }\n    });\n  }\n\n  playAudio() {\n    if (environment.PLAY_AUDIO_ON_REQUEST == true) {\n      this.audio = new Audio(environment.AUDIO_PATH);\n      this.audio.play();\n    }\n  }\n\n  stopAudio() {\n    this.audio.pause();\n  }\n\n  cancel() {\n    this.ui.presentAlert({\n      mode: 'ios',\n      header: \"\",\n      message: \"\",\n      buttons: [{\n        text: 'Aceptar',\n        cssClass: 'secondary',\n        handler: res => __awaiter(this, void 0, void 0, function* () {})\n      }]\n    });\n  }\n\n  verified() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.user.verified == 0) {\n        let header = \"¡Para ponerte disponible, primero debes ser verificado!\";\n        let message;\n        this.ui.presentAlert({\n          mode: 'ios',\n          header,\n          message,\n          buttons: [{\n            text: 'Aceptar',\n            role: 'cancel',\n            cssClass: 'secondary',\n            handler: res => {\n              console.log('cerrar');\n            }\n          }]\n        });\n      } else {\n        if (this.network.getNetworkStatus().connected) {\n          const loader = yield this.loadingController.create({\n            message: \"Por favor espere...\",\n            mode: 'ios'\n          });\n          yield loader.present();\n\n          try {\n            let latitude;\n            let longitude;\n\n            if (localStorage.getItem(\"latitude\") && localStorage.getItem(\"longitude\")) {\n              latitude = localStorage.getItem(\"latitude\");\n              longitude = localStorage.getItem(\"longitude\");\n            } else {\n              const position = yield Geolocation.getCurrentPosition({// enableHighAccuracy: true\n              });\n              latitude = position.coords.latitude;\n              longitude = position.coords.longitude;\n            }\n\n            localStorage.setItem(\"latitude\", latitude.toString());\n            localStorage.setItem(\"longitude\", longitude.toString());\n            this.auth.user.available = this.auth.user.available == 1 ? 0 : 1;\n            this.user.available = this.auth.user.available;\n            this.request.post(`driver/change_availability/${this.auth.user.id}`, {\n              latitude,\n              longitude,\n              available: this.auth.user.available\n            }).subscribe(res => __awaiter(this, void 0, void 0, function* () {\n              (yield loader).dismiss();\n              this.realtime.getUserGeolocation().update({\n                key: this.auth.user.id,\n                user_id: this.auth.user.id,\n                latitude: latitude.toString(),\n                longitude: longitude.toString(),\n                city_id: this.auth.person.city_id,\n                state_id: Number(this.auth.person.state_id),\n                level_id: Number(this.auth.user.level_id),\n                // last_active: Date.now(),\n                available: this.auth.user.available,\n                driver_name: this.auth.user.name,\n                transport_type_id: this.auth.vehicles.transport_type_id\n              });\n\n              if (this.auth.user.available == 0) {\n                Geolocation.clearWatch({\n                  id: this.watchPositionId\n                });\n\n                if (Capacitor.platform != 'web') {\n                  yield BackgroundGeolocation.stop();\n                } // await this.backgroundGeolocation.removeAllListeners();\n\n              } else {\n                this.startPosition();\n              }\n\n              this.auth.setUser(this.auth.user);\n\n              if (this.auth.user.available == 1) {\n                this.ui.showToast(\"El usuario ahora está disponible\");\n                this.loadData();\n              } else {\n                // this.geolocation.stopWatching();\n                this.ui.showToast(\"El usuario ahora  no está disponible\");\n                const id = localStorage.getItem(\"watchPositionId\");\n\n                if (id) {\n                  Geolocation.clearWatch({\n                    id\n                  });\n                }\n              }\n            }), err => __awaiter(this, void 0, void 0, function* () {\n              (yield loader).dismiss();\n              this.ui.showToast(\"Hubo un error y  no se pudo poner disponible\");\n              this.auth.user.available = this.auth.user.available == 1 ? 0 : 1;\n              this.user.available = this.auth.user.available;\n              console.log('error');\n            }));\n          } catch (e) {\n            (yield loader).dismiss();\n            this.ui.presentAlert({\n              mode: 'ios',\n              header: \"Advertencia\",\n              message: \"Su ubicación no está disponible, por favor verificar el estado del GPS\",\n              buttons: [{\n                text: 'Aceptar',\n                cssClass: 'secondary',\n                handler: res => __awaiter(this, void 0, void 0, function* () {})\n              }]\n            });\n            console.log(\"Error\", e);\n          }\n        } else {\n          this.ui.showToast(\"Verifique su conexión\");\n        }\n      }\n    });\n  }\n\n  loadData() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.network.getNetworkStatus().connected) {\n        this.spinner = true;\n        let loader;\n\n        if (!localStorage.getItem(\"current_order\")) {\n          loader = yield this.ui.loading(\"Por favor espere...\");\n        }\n\n        this.orders = [];\n        this.request.get(`driver/list_current_orders/${this.auth.user.id}`).subscribe(res => __awaiter(this, void 0, void 0, function* () {\n          this.refresher.complete();\n          this.spinner = false;\n          this.orders = res.data.data;\n          console.log(\"Orders\", this.orders);\n          this.orders.forEach(order => {\n            this.setOrderReminder(order);\n          });\n\n          if (loader) {\n            this.request.get(`driver/documents/${this.auth.user.id}`).subscribe(res => __awaiter(this, void 0, void 0, function* () {\n              if (!localStorage.getItem(\"current_order\")) {\n                (yield loader).dismiss();\n              }\n\n              const documents = res.data.documents;\n              const photo = documents.filter(d => d[\"document_type \"] == \"Foto del conductor\");\n\n              if (photo.length > 0) {\n                this.image = photo[photo.length - 1].url;\n              }\n            }), err => __awaiter(this, void 0, void 0, function* () {\n              if (!localStorage.getItem(\"current_order\")) {\n                (yield loader).dismiss();\n              }\n            }));\n          }\n        }), err => {\n          this.refresher.complete();\n\n          if (loader) {\n            this.request.get(`driver/documents/${this.auth.user.id}`).subscribe(res => __awaiter(this, void 0, void 0, function* () {\n              if (!localStorage.getItem(\"current_order\")) {\n                (yield loader).dismiss();\n              }\n\n              const documents = res.data.documents;\n              const photo = documents.filter(d => d[\"document_type \"] == \"Foto del conductor\");\n\n              if (photo.length > 0) {\n                this.image = photo[photo.length - 1].url;\n              }\n            }), err => __awaiter(this, void 0, void 0, function* () {\n              if (!localStorage.getItem(\"current_order\")) {\n                (yield loader).dismiss();\n              }\n            }));\n          }\n\n          this.spinner = false;\n        });\n      } else {\n        this.ui.showToast(\"Verifique su conexión\");\n      }\n    });\n  }\n\n  filter() {\n    return this.orders.filter(a => a.status_order != 25);\n  }\n\n  filterOrderNear() {\n    if (this.auth.person.ordersNearYou) {\n      return this.auth.person.ordersNearYou.filter(o => !this.orders.find(or => o.id == or.id)).sort((a, b) => new Date(a.creation_date).getTime() - new Date(b.creation_date).getTime());\n    }\n\n    return [];\n  }\n\n  viewDetail(order) {\n    return __awaiter(this, void 0, void 0, function* () {\n      console.log(\"Order\", order);\n\n      if (this.network.getNetworkStatus().connected) {\n        if (this.user.available != 0) {\n          //Validate the isn't about to end \n\n          /**\n           * The order is about to end\n           * When All the status from order details are finished or not effective\n           */\n          if (!this.isAboutToEnd(order)) {\n            if (order.status_order == 22 || order.status_order == 23) {\n              if (order.service_type_id == 3) {\n                //Validate if the order is currently active\n                const {\n                  message,\n                  active\n                } = yield this.isOrderActive(order, true);\n\n                if (active) {\n                  // this.stopPosition();\n                  // const loader = await this.ui.loading(\"Por favor espere...\");\n                  try {\n                    //Validate if te user is near to the address\n                    const current_latitude = parseFloat(localStorage.getItem(\"latitude\"));\n                    const current_longitude = parseFloat(localStorage.getItem(\"longitude\"));\n                    const latitude = order.details[0].latitude;\n                    const longitude = order.details[0].longitude;\n                    const distance = this.place.calcCrow(latitude, longitude, current_latitude, current_longitude);\n                    console.log(\"Distance\", distance);\n\n                    if (distance <= 1) {\n                      console.log(\"Está ahí\");\n                      yield this.ui.presentAlert({\n                        mode: 'ios',\n                        header: '¿Quieres iniciar el viaje?',\n                        buttons: [{\n                          text: 'No',\n                          role: 'cancel',\n                          cssClass: 'secondary',\n                          handler: blah => {\n                            console.log('Confirm Cancel: blah');\n                          }\n                        }, {\n                          text: 'Sí',\n                          handler: () => __awaiter(this, void 0, void 0, function* () {\n                            localStorage.setItem(\"current_order\", JSON.stringify(order));\n                            const modal = yield this.ui.presentModal(ViewDetailPage, {\n                              order\n                            }, 'custom-modal');\n                            modal.onDidDismiss().then(data => {\n                              this.loadData();\n                            });\n                          })\n                        }]\n                      });\n                    } else {\n                      yield this.ui.presentAlert({\n                        mode: 'ios',\n                        header: 'Advertencia',\n                        message: 'Debe estar en el punto para iniciar el servicio',\n                        buttons: [{\n                          text: 'Aceptar',\n                          role: 'cancel',\n                          cssClass: 'secondary',\n                          handler: blah => {\n                            console.log('Confirm Cancel: blah');\n                          }\n                        }]\n                      });\n                    }\n                  } catch (e) {\n                    console.log(\"Error\", e);\n                  }\n                } else {\n                  yield this.ui.presentAlert({\n                    mode: 'ios',\n                    header: 'Advertencia',\n                    message,\n                    buttons: [{\n                      text: 'Aceptar',\n                      role: 'cancel',\n                      cssClass: 'secondary',\n                      handler: blah => {\n                        console.log('Confirm Cancel: blah');\n                      }\n                    }]\n                  });\n                }\n              } else {\n                localStorage.setItem(\"current_order\", JSON.stringify(order));\n                const modal = yield this.ui.presentModal(ViewDetailPage, {\n                  order,\n                  latLng: this.latLng\n                }, 'custom-modal');\n                modal.onDidDismiss().then(data => {\n                  this.loadData();\n                });\n              }\n            } else {\n              //Validate if the order status isn´t end or not effective or cancelled or cancelled by the delivery\n              if (order.status_order != 25 && order.status_order != 48 && order.status_order != 31 && order.status_order != 36 && !this.isAboutToEnd(order)) {\n                //When I'll load the order, I  could update the proximity with it current value on the SQL database\n                this.realtime.getNewOrder().update({\n                  proximity: order.proximity\n                });\n                localStorage.setItem(\"current_order\", JSON.stringify(order));\n                const modal = yield this.ui.presentModal(ViewDetailPage, {\n                  order,\n                  latLng: this.latLng\n                }, 'custom-modal');\n                modal.onDidDismiss().then(r => {\n                  localStorage.removeItem(\"current_order\");\n                  this.loadData();\n                });\n              }\n            }\n          }\n        } else {\n          this.ui.showToast(\"Debe estar disponible\");\n        }\n      } else {\n        this.ui.showToast(\"Por favor, verifique su conexión\");\n      }\n    });\n  }\n  /**\n   * This function is only for time service\n   * It build two notification\n   * The first one, it show inmediately and the other\n   * is scheduled 5 minutes before the start hour that the client put\n   * on the order\n   * the client\n   * @param order\n   */\n\n\n  setOrderReminder(order) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (order) {\n          //Validate if the order service type is for time\n          if (order.service_type_id == 3) {\n            //Validate the order is active\n            //Validate if the order is currently active\n            const {\n              message,\n              active\n            } = yield this.isOrderActive(order);\n\n            if (active) {\n              const details = order.detail ? order.detail : order.details;\n              const start_time = order.detail ? order.detail[0].start_time_military_format : order.details[0].start_time_military_format;\n              const now = new Date();\n              const now_hour = now.getHours() + \":\" + now.getMinutes();\n              const differenceInHours = this.days.getHourDiff(start_time, now_hour);\n              const id = Math.round(Math.random() * 100); //Validate if the ordeer reminder doesn´t exists\n\n              if (!localStorage.getItem(\"order_reminder\" + order.id)) {\n                const startDate = order.date + \" \" + start_time;\n                console.log(\"Start Date Service\", startDate);\n                const startTimeDate = new Date(startDate);\n                console.log(\"Start Date Service new Date\", new Date(startDate));\n                const oneHourBeforeDate = this.days.substractHours(new Date(startDate), 1);\n                const fiveMinutesBeforeDate = this.days.substractMinutes(new Date(startDate), 5);\n                console.log(\"Start Date Service One hour before \", oneHourBeforeDate);\n                console.log(\"Start Date Service Five minutes \", fiveMinutesBeforeDate);\n                const notificationsToSend = [];\n                const oneHourBeforeObject = {\n                  hour: oneHourBeforeDate.getHours(),\n                  minute: oneHourBeforeDate.getMinutes()\n                };\n                const fiveMinutesBeforeObject = {\n                  hour: fiveMinutesBeforeDate.getHours(),\n                  minute: fiveMinutesBeforeDate.getMinutes()\n                };\n                const startTimeObject = {\n                  hour: startTimeDate.getHours(),\n                  minute: startTimeDate.getMinutes()\n                };\n                /**\n                * This validation calculate the difference and its\n                * true when current time is between one hour before and 10(ten) minutes\n                * after the start_time\n                */\n\n                if (differenceInHours > -1 && differenceInHours <= 0.1) {\n                  notificationsToSend.push(\n                  /**\n                  * Inmediately notification to\n                  * alert the user\n                  */\n                  {\n                    title: \"Orden \" + order.id,\n                    body: \"Recuerda que debes estar a las \" + details[0].start_time + \" en el lugar\",\n                    id: Math.round(Math.random() * 100),\n                    autoCancel: true,\n                    channelId: 'pop-notifications'\n                  });\n                }\n\n                notificationsToSend.push(\n                /**\n                * This notification is scheduled to show one hour before\n                * the start_time\n                */\n                {\n                  title: \"Orden \" + order.id,\n                  body: \"Recuerda que debes estar a las \" + details[0].start_time + \" en el lugar\",\n                  schedule: {\n                    on: oneHourBeforeObject\n                  },\n                  id: Math.round(Math.random() * 100),\n                  autoCancel: true,\n                  channelId: 'pop-notifications'\n                });\n                notificationsToSend.push(\n                /**\n                 * This notification is scheduled to show five minutes before\n                 * the start_time\n                 */\n                {\n                  title: \"Orden \" + order.id,\n                  body: \"Recuerda que debes estar a las \" + details[0].start_time + \" en el lugar faltan cinco minutos\",\n                  schedule: {\n                    on: fiveMinutesBeforeObject\n                  },\n                  id: Math.round(Math.random() * 100),\n                  autoCancel: true,\n                  channelId: 'pop-notifications'\n                });\n                notificationsToSend.push(\n                /**\n                 * This notification is scheduled to show at the hour\n                 * the start_time\n                 */\n                {\n                  title: \"Orden \" + order.id,\n                  body: \"¡Ya es hora! \" + \" Ve a la dirección \" + details[0].address,\n                  schedule: {\n                    on: startTimeObject\n                  },\n                  id: Math.round(Math.random() * 100),\n                  autoCancel: true,\n                  channelId: 'pop-notifications'\n                });\n                /**\n                 * This is the first notification shown\n                 */\n                //Show the local notificattions\n\n                yield LocalNotifications.schedule({\n                  notifications: notificationsToSend\n                });\n                localStorage.setItem(\"order_reminder\" + order.id, \"notified\");\n              }\n            }\n          }\n        } else {\n          this.ui.showToast(\"No hay orden\");\n        }\n      } catch (e) {\n        console.log(\"Error Notification\", e);\n        this.ui.showToast(\"Error\" + JSON.stringify(e));\n      }\n    });\n  }\n\n  getIsOrderActive(order) {\n    const {\n      active,\n      message\n    } = this.isOrderActive(order);\n    return {\n      active,\n      message\n    };\n  }\n\n  isOrderActive(order, validateHourDifference = true) {\n    //Validate if the order is currently active\n    const date_service = new Date(order.date);\n    const today = new Date();\n    const today_date = {\n      day: today.getDate(),\n      month: today.getMonth() + 1,\n      year: today.getFullYear()\n    };\n    const date_split = order.date.split(\"-\");\n    const date_service_date = {\n      day: Number(date_split[2]),\n      month: Number(date_split[1]),\n      year: Number(date_split[0])\n    };\n    const isToday = Object.keys(today_date).every(key => {\n      return today_date[key] == date_service_date[key];\n    });\n\n    if (isToday) {\n      if (order.service_type_id == 3) {\n        const details = order.detail ? order.detail : order.details;\n        const start_time = order.detail ? order.detail[0].start_time_military_format : order.details[0].start_time_military_format;\n        const now = new Date();\n        const now_hour = now.getHours() + \":\" + now.getMinutes();\n        const differenceInHours = this.days.getHourDiff(start_time, now_hour);\n        const id = Math.round(Math.random() * 100);\n        /**\n         * This validation calculate the difference and its\n         * true when current time is between one hour before and 10(ten) minutes\n         * after the start_time\n         */\n\n        if (validateHourDifference) {\n          if (differenceInHours > -1 && differenceInHours <= 0.1) {\n            return {\n              active: true,\n              message: \"\"\n            };\n          } else {\n            return {\n              active: false,\n              message: \"Debe estar en la dirección en el horario establecido\"\n            };\n          }\n        } else {\n          if (differenceInHours == 0) {\n            return {\n              active: true,\n              message: \"\"\n            };\n          } else {\n            return {\n              active: false,\n              message: \"Debe estar en la dirección en el horario establecido\"\n            };\n          }\n        }\n      } else {\n        return {\n          active: true,\n          message: \"\"\n        };\n      }\n    } else {\n      return {\n        active: false,\n        message: \"El día del servicio ha pasado \"\n      };\n    }\n  }\n\n};\n\n__decorate([ViewChild(IonRefresher, {\n  read: IonRefresher,\n  static: false\n})], HomePage.prototype, \"refresher\", void 0);\n\nHomePage = __decorate([Component({\n  selector: 'app-home',\n  templateUrl: './home.page.html',\n  styleUrls: ['./home.page.scss']\n})], HomePage);\nexport { HomePage };","map":null,"metadata":{},"sourceType":"module"}