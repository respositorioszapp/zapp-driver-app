{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { Capacitor, Plugins, Geolocation } from '@capacitor/core';\nimport { take } from 'rxjs/operators';\nimport { environment } from 'src/environments/environment';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./realtime.service\";\nimport * as i2 from \"./auth.service\";\nimport * as i3 from \"./network-status.service\";\nimport * as i4 from \"@awesome-cordova-plugins/foreground-service/ngx\";\nconst {\n  App,\n  BackgroundTask\n} = Plugins;\nexport let BackgroundService = /*#__PURE__*/(() => {\n  class BackgroundService {\n    constructor(realtime, auth, network, zone, foregroundService) {\n      this.realtime = realtime;\n      this.auth = auth;\n      this.network = network;\n      this.zone = zone;\n      this.foregroundService = foregroundService;\n    }\n    /**\n     * Start Background MOde\n     * This function make the app can work work as a background service\n     * It take 3 steps, if one failed the others won't execute anything\n     * 1. Check if the user is available\n     * 2. Check if the device has FOREGROUND_SERVICE permission\n     * 3. Enable the background mode\n     */\n\n\n    startBackgroundMode() {\n      return __awaiter(this, void 0, void 0, function* () {\n        App.addListener(\"appStateChange\", state => {\n          clearInterval(this.interval); // if (Capacitor.platform !== 'web') {\n          // }\n          // if (this.geoLocationSubscription) {\n          //   this.geoLocationSubscription.unsubscribe()\n          // }\n\n          console.log(\"Background mode\");\n\n          if (!state.isActive) {\n            if (this.auth.user != null && this.auth.user.available != 0) {\n              if (Capacitor.platform !== 'web') {\n                console.log(\"Foreground START\");\n                this.foregroundService.start('GPS Running', 'Background Service');\n              } else {}\n            }\n          } else {\n            if (Capacitor.platform !== 'web') {\n              this.foregroundService.stop();\n            }\n          }\n        });\n      });\n    }\n\n    startWatchingPosition(mode) {\n      // if (this.watchPositionId) {\n      //   Geolocation.clearWatch({ id: this.watchPositionId });\n      // }\n      // if (this.geoLocationSubscription) {\n      //   this.geoLocationSubscription.unsubscribe();\n      // }\n      if (this.auth.user != null && this.auth.user.available != 0) {\n        this.watchPositionId = Geolocation.watchPosition({\n          enableHighAccuracy: true\n        }, (position, err) => {\n          console.log(\"This is my position\", mode);\n          localStorage.setItem(\"latitude\", position.coords.latitude.toString());\n          localStorage.setItem(\"longitude\", position.coords.longitude.toString());\n          this.geoLocationSubscription = this.realtime.getUserGeolocation().valueChanges().pipe(take(1)).subscribe(snapshot => {\n            console.log(snapshot);\n            console.log(\"This is my position 2\", mode);\n\n            if (snapshot === null) {\n              this.realtime.getUserGeolocation().set({\n                key: this.auth.user.id,\n                user_id: this.auth.user.id,\n                latitude: position.coords.latitude.toString(),\n                longitude: position.coords.longitude.toString(),\n                city_id: this.auth.person.city_id,\n                state_id: Number(this.auth.person.state_id),\n                level_id: Number(this.auth.user.level_id),\n                // last_active: Date.now(),\n                available: this.auth.user.available,\n                driver_name: this.auth.user.name,\n                transport_type_id: this.auth.vehicles.transport_type_id,\n                code: environment.VERSION_NAME\n              });\n            } else {\n              // update\n              this.realtime.getUserGeolocation().update({\n                key: this.auth.user.id,\n                user_id: this.auth.user.id,\n                latitude: position.coords.latitude.toString(),\n                longitude: position.coords.longitude.toString(),\n                city_id: this.auth.person.city_id,\n                state_id: Number(this.auth.person.state_id),\n                level_id: Number(this.auth.user.level_id),\n                // last_active: Date.now(),\n                available: this.auth.user.available,\n                driver_name: this.auth.user.name,\n                transport_type_id: this.auth.vehicles.transport_type_id,\n                code: environment.VERSION_NAME\n              });\n            }\n          });\n        });\n      }\n    }\n    /**\n     * Stop Background Mode\n     * This is necessary when the user isn't available\n     */\n\n\n    stopBackgroundMode() {\n      clearInterval(this.interval);\n\n      if (this.watchPositionId) {}\n\n      if (this.geoLocationSubscription) {\n        this.geoLocationSubscription.unsubscribe();\n      }\n\n      if (Capacitor.platform !== 'web') {// if (this.backgroundMode.isActive) {\n        //   this.backgroundMode.setEnabled(false);\n        //   this.backgroundMode.disable();\n        // }\n        // this.foregroundService.stop();\n      }\n    }\n\n    checkStatus() {\n      return __awaiter(this, void 0, void 0, function* () {});\n    }\n\n  }\n\n  BackgroundService.ɵfac = function BackgroundService_Factory(t) {\n    return new (t || BackgroundService)(i0.ɵɵinject(i1.RealtimeService), i0.ɵɵinject(i2.AuthService), i0.ɵɵinject(i3.NetworkStatusService), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i4.ForegroundService));\n  };\n\n  BackgroundService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: BackgroundService,\n    factory: BackgroundService.ɵfac,\n    providedIn: 'root'\n  });\n  return BackgroundService;\n})();","map":null,"metadata":{},"sourceType":"module"}