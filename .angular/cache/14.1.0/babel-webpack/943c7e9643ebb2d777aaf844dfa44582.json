{"ast":null,"code":"import { __awaiter, __decorate } from \"tslib\";\nimport { Injectable } from '@angular/core';\nimport { Capacitor, Plugins, Geolocation } from '@capacitor/core';\nconst {\n  App,\n  BackgroundTask\n} = Plugins;\nimport { take } from 'rxjs/operators';\nimport { environment } from 'src/environments/environment';\nlet BackgroundService = class BackgroundService {\n  constructor(realtime, auth, network, zone, foregroundService) {\n    this.realtime = realtime;\n    this.auth = auth;\n    this.network = network;\n    this.zone = zone;\n    this.foregroundService = foregroundService;\n  }\n  /**\n   * Start Background MOde\n   * This function make the app can work work as a background service\n   * It take 3 steps, if one failed the others won't execute anything\n   * 1. Check if the user is available\n   * 2. Check if the device has FOREGROUND_SERVICE permission\n   * 3. Enable the background mode\n   */\n\n\n  startBackgroundMode() {\n    return __awaiter(this, void 0, void 0, function* () {\n      App.addListener(\"appStateChange\", state => {\n        clearInterval(this.interval); // if (Capacitor.platform !== 'web') {\n        // }\n        // if (this.geoLocationSubscription) {\n        //   this.geoLocationSubscription.unsubscribe()\n        // }\n\n        console.log(\"Background mode\");\n\n        if (!state.isActive) {\n          if (this.auth.user != null && this.auth.user.available != 0) {\n            if (Capacitor.platform !== 'web') {\n              console.log(\"Foreground START\");\n              this.foregroundService.start('GPS Running', 'Background Service');\n            } else {}\n          }\n        } else {\n          if (Capacitor.platform !== 'web') {\n            this.foregroundService.stop();\n          }\n        }\n      });\n    });\n  }\n\n  startWatchingPosition(mode) {\n    // if (this.watchPositionId) {\n    //   Geolocation.clearWatch({ id: this.watchPositionId });\n    // }\n    // if (this.geoLocationSubscription) {\n    //   this.geoLocationSubscription.unsubscribe();\n    // }\n    if (this.auth.user != null && this.auth.user.available != 0) {\n      this.watchPositionId = Geolocation.watchPosition({\n        enableHighAccuracy: true\n      }, (position, err) => {\n        console.log(\"This is my position\", mode);\n        localStorage.setItem(\"latitude\", position.coords.latitude.toString());\n        localStorage.setItem(\"longitude\", position.coords.longitude.toString());\n        this.geoLocationSubscription = this.realtime.getUserGeolocation().valueChanges().pipe(take(1)).subscribe(snapshot => {\n          console.log(snapshot);\n          console.log(\"This is my position 2\", mode);\n\n          if (snapshot === null) {\n            this.realtime.getUserGeolocation().set({\n              key: this.auth.user.id,\n              user_id: this.auth.user.id,\n              latitude: position.coords.latitude.toString(),\n              longitude: position.coords.longitude.toString(),\n              city_id: this.auth.person.city_id,\n              state_id: Number(this.auth.person.state_id),\n              level_id: Number(this.auth.user.level_id),\n              // last_active: Date.now(),\n              available: this.auth.user.available,\n              driver_name: this.auth.user.name,\n              transport_type_id: this.auth.vehicles.transport_type_id,\n              code: environment.VERSION_NAME\n            });\n          } else {\n            // update\n            this.realtime.getUserGeolocation().update({\n              key: this.auth.user.id,\n              user_id: this.auth.user.id,\n              latitude: position.coords.latitude.toString(),\n              longitude: position.coords.longitude.toString(),\n              city_id: this.auth.person.city_id,\n              state_id: Number(this.auth.person.state_id),\n              level_id: Number(this.auth.user.level_id),\n              // last_active: Date.now(),\n              available: this.auth.user.available,\n              driver_name: this.auth.user.name,\n              transport_type_id: this.auth.vehicles.transport_type_id,\n              code: environment.VERSION_NAME\n            });\n          }\n        });\n      });\n    }\n  }\n  /**\n   * Stop Background Mode\n   * This is necessary when the user isn't available\n   */\n\n\n  stopBackgroundMode() {\n    clearInterval(this.interval);\n\n    if (this.watchPositionId) {}\n\n    if (this.geoLocationSubscription) {\n      this.geoLocationSubscription.unsubscribe();\n    }\n\n    if (Capacitor.platform !== 'web') {// if (this.backgroundMode.isActive) {\n      //   this.backgroundMode.setEnabled(false);\n      //   this.backgroundMode.disable();\n      // }\n      // this.foregroundService.stop();\n    }\n  }\n\n  checkStatus() {\n    return __awaiter(this, void 0, void 0, function* () {});\n  }\n\n};\nBackgroundService = __decorate([Injectable({\n  providedIn: 'root'\n})], BackgroundService);\nexport { BackgroundService };","map":null,"metadata":{},"sourceType":"module"}